# Примеры реального применения sync.Mutex, RWMutex, sync.Map и WaitGroup

Документ показывает **как правильно применять примитивы синхронизации в
Go** и **почему именно так**.

------------------------------------------------------------------------

# 1. Глобальный Mutex для общей переменной

``` go
var mu sync.Mutex
var counter int

func Inc() {
    mu.Lock()
    counter++
    mu.Unlock()
}
```

### Почему так применяют

-   Глобальная переменная `counter` используется **несколькими
    горутинами**.
-   Нужен **один общий мьютекс**, чтобы никто не записал одновременно.
-   Подходит, когда структура маленькая и нет необходимости
    инкапсулировать состояние.

------------------------------------------------------------------------

# 2. Встраивание Mutex в структуру

``` go
type SafeMap struct {
    mu sync.Mutex
    m  map[string]int
}

func (s *SafeMap) Set(k string, v int) {
    s.mu.Lock()
    s.m[k] = v
    s.mu.Unlock()
}

func (s *SafeMap) Get(k string) int {
    s.mu.Lock()
    defer s.mu.Unlock()
    return s.m[k]
}
```

### Почему так применяют

-   Мьютекс **«принадлежит» данным**, а не вызывающему коду.
-   Никто снаружи не забудет вызвать `Lock()`.
-   Структура сама отвечает за **свою безопасность**.
-   Это лучший подход для большинства случаев.

------------------------------------------------------------------------

# 3. RWMutex --- оптимизация при большом количестве чтений

``` go
type Cache struct {
    mu sync.RWMutex
    data map[string]string
}

func (c *Cache) Get(k string) string {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return c.data[k]
}

func (c *Cache) Set(k, v string) {
    c.mu.Lock()
    c.data[k] = v
    c.mu.Unlock()
}
```

### Почему так применяют

-   Много горутин **читают**, мало --- **пишут**.
-   `RLock()` позволяет нескольким читателям идти параллельно.
-   Блокировка на запись (`Lock()`) даёт эксклюзивный доступ.

Использование `RWMutex` ускоряет программы, где **чтений больше 5--10×,
чем записей**.

------------------------------------------------------------------------

# 4. sync.Map --- конкурентная map без мьютексов

``` go
var users sync.Map

func AddUser(id int, name string) {
    users.Store(id, name)
}

func GetUser(id int) (string, bool) {
    v, ok = users.Load(id)
    if !ok {
        return "", false
    }
    return v.(string), true
}
```

### Почему так применяют

-   `sync.Map` оптимизирован под паттерн:
    -   **много чтений**
    -   **редкие записи**
-   Не нужно писать свои Lock/Unlock.
-   Внутри --- сложная стратегия хранения (read-only + dirty map).
-   Идеален для кэшей, конфигов, общих справочников.

------------------------------------------------------------------------

# 5. Sharded Mutex --- ускорение map через разделение

``` go
type Sharded struct {
    mu  [256]sync.Mutex
    arr [256]int
}

func (s *Sharded) Add(i int) {
    idx := i % 256
    s.mu[idx].Lock()
    s.arr[idx]++
    s.mu[idx].Unlock()
}
```

### Почему так применяют

-   Один мьютекс → узкое место.
-   256 мьютексов → шанс коллизии минимален.
-   Горутин больше не блокируют друг друга при обращении к разным
    сегментам.
-   Это даёт **значительный прирост производительности**.

------------------------------------------------------------------------

# 6. WaitGroup --- ожидание завершения горутин

``` go
func ProcessAll(items []int) {
    var wg sync.WaitGroup

    for _, item := range items {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            process(i)
        }(item)
    }

    wg.Wait()
}
```

### Почему так применяют

-   `WaitGroup` позволяет **дождаться завершения всех горутин**.
-   Никаких мьютексов, блокировок, каналов.
-   Очень удобно для параллельной обработки массива данных.

------------------------------------------------------------------------

# 7. Комбинация RWMutex + WaitGroup

``` go
type SafeCache struct {
    mu    sync.RWMutex
    cache map[string]string
}

func Process(c *SafeCache, keys []string) {
    var wg sync.WaitGroup

    for _, k := range keys {
        wg.Add(1)
        go func(key string) {
            defer wg.Done()

            c.mu.RLock()
            val := c.cache[key]
            c.mu.RUnlock()

            fmt.Println(val)
        }(k)
    }

    wg.Wait()
}
```

### Почему так применяют

-   Много параллельных чтений --- используем `RLock`.
-   Ждём всех --- используем `WaitGroup`.
-   Это реальный паттерн из продакшена (кэш + параллельные запросы).

------------------------------------------------------------------------

# 8. Реалистичный пример: очередь задач + мьютекс

``` go
type Queue struct {
    mu sync.Mutex
    q  []int
}

func (q *Queue) Push(x int) {
    q.mu.Lock()
    q.q = append(q.q, x)
    q.mu.Unlock()
}

func (q *Queue) Pop() (int, bool) {
    q.mu.Lock()
    defer q.mu.Unlock()

    if len(q.q) == 0 {
        return 0, false
    }
    x := q.q[0]
    q.q = q.q[1:]
    return x, true
}
```

### Почему так применяют

-   Очередь --- изменяемая структура
-   Несколько горутин могут:
-   добавлять элементы
-   забирать элементы
-   Один мьютекс полностью решает проблему гонок данных.

------------------------------------------------------------------------

# Итоги
```
  ------------------------------------------------------------------------
  Примитив                Для чего                   Почему
  ----------------------- -------------------------- ---------------------
  `Mutex`                 защита данных от           простой, быстрый
                          одновременной записи       

  `RWMutex`               много чтений, мало записей параллельные чтения

  `sync.Map`              кэши, справочники          быстро при редких
                                                     записях

  `WaitGroup`             ждать завершения горутин   синхронизация без
                                                     блокировок

  Sharding                уменьшение блокировок      резкий рост
                                                     производительности
  ------------------------------------------------------------------------

  ------------------------------------------------------------------------
```
